<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor - Fractal Effects</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles (similar to previous version) */
        body { font-family: 'Inter', sans-serif; }
        #canvasContainer { max-width: 100%; max-height: 60vh; overflow: auto; margin: 1rem auto; border: 1px dashed #d1d5db; border-radius: 0.5rem; background-color: #f9fafb; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; border-radius: 0.25rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); image-rendering: pixelated; transform-origin: top left; transition: transform 0.1s ease-out; max-width: none !important; }
        button, label, select, input[type="number"], input[type="checkbox"] { cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease, border-color 0.3s ease, box-shadow 0.1s ease; margin: 0 0.25rem; padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid #d1d5db; font-size: 0.875rem; vertical-align: middle; }
        button, label[for="imageLoader"] { border: 1px solid transparent; background-color: #6366f1; color: white; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        button:hover, label[for="imageLoader"]:hover { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        label[for="imageLoader"] { background-color: #3b82f6; } label[for="imageLoader"]:hover { background-color: #2563eb; }
        #applyEffectButton { background-color: #a855f7; } #applyEffectButton:hover { background-color: #9333ea; }
        #resetButton { background-color: #f59e0b; } #resetButton:hover { background-color: #d97706; }
        #saveButton { background-color: #22c55e; } #saveButton:hover { background-color: #16a34a; }
        #undoButton, #redoButton, .zoom-button { background-color: #6b7280; padding: 0.4rem 0.8rem; }
        #undoButton:hover, #redoButton:hover, .zoom-button:hover { background-color: #4b5563; }
        button:active, label:active { transform: scale(0.98) translateY(1px); box-shadow: none; }
        button:disabled, select:disabled, input[type="range"]:disabled, input[type="number"]:disabled, input[type="checkbox"]:disabled { opacity: 0.5; cursor: not-allowed; background-color: #e5e7eb !important; color: #6b7280 !important; border-color: #d1d5db !important; box-shadow: none; }
        select { background-color: white; padding: 0.5rem 2rem 0.5rem 0.75rem; }
        input[type="number"] { width: 80px; text-align: right; padding-right: 0.5rem; -moz-appearance: textfield; appearance: textfield; }
        input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type="checkbox"] { width: 1rem; height: 1rem; padding: 0; margin-right: 0.5rem; border-radius: 0.25rem; accent-color: #6366f1; border: 1px solid #d1d5db; }
        input[type="range"] { cursor: pointer; width: 120px; vertical-align: middle; accent-color: #6366f1; }
        input[type="file"] { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        .controls-container { margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .control-row { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 0.5rem 0.75rem; width: 100%; }
        .effect-options { display: flex; flex-direction: column; align-items: center; gap: 1rem; width: 100%; margin-top: 0.5rem; padding: 0.5rem; }
        .effect-option-group { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 0.5rem 1.5rem; width: 100%; padding-bottom: 0.5rem; border-bottom: 1px dotted #e5e7eb; }
        .effect-option-group:last-child { border-bottom: none; }
        .effect-option-group > div { display: flex; align-items: center; gap: 0.5rem; }
        .effect-option-label { font-weight: 600; color: #4b5563; margin-bottom: 0.5rem; width: 100%; text-align: center; font-size: 0.9rem; padding-bottom: 0.25rem; }
        .control-row label { margin: 0; font-size: 0.875rem; color: #4b5563; font-weight: 500; border: none; padding: 0.5rem 0; background-color: transparent; white-space: nowrap; }
        .control-row label[for="keepAspectRatio"] { padding: 0; margin-left: -0.25rem; user-select: none; }
        .control-row span { font-size: 0.875rem; color: #4b5563; min-width: 25px; text-align: right; font-family: monospace; }
        #realtimeWarning { font-size: 0.75rem; color: #ef4444; margin-top: -0.5rem; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 md:p-8 rounded-lg shadow-lg w-full max-w-4xl text-center">
        <h1 class="text-2xl md:text-3xl font-bold mb-6 text-gray-800">Image Editor - Fractal Effects</h1>

        <div class="mb-4">
            <label for="imageLoader" class="inline-block text-white font-medium py-2 px-4 rounded-lg shadow">Load Image</label>
            <input type="file" id="imageLoader" name="imageLoader" accept="image/*" class="hidden"/>
            <p id="fileName" class="text-sm text-gray-500 mt-2">No image selected</p>
        </div>

        <div id="canvasContainer" class="mb-4 min-h-[200px]">
             <canvas id="imageCanvas" class="hidden"></canvas>
             <p id="canvasPlaceholder" class="text-gray-400">Image will appear here</p>
        </div>

         <div id="zoomControls" class="control-row mb-4 hidden">
             <label>Zoom:</label>
             <button id="zoomOutButton" class="zoom-button" title="Zoom Out" disabled>-</button>
             <button id="zoomResetButton" class="zoom-button" title="Reset Zoom" disabled>100%</button>
             <button id="zoomInButton" class="zoom-button" title="Zoom In" disabled>+</button>
        </div>

        <div id="controls" class="controls-container hidden">
             <div class="control-row">
                <label for="effectSelector">Effect:</label>
                <select id="effectSelector" class="shadow-sm">
                    <option value="noise">Noise</option>
                    <option value="scanLines">Scan Lines</option>
                    <option value="waveDistortion">Wave Distortion</option>
                    <option value="fractalZoom">Fractal Zoom</option>
                    <option value="juliaSet">Julia Set</option> </select>
                <button id="undoButton" title="Undo Last Apply" disabled>Undo</button>
                <button id="redoButton" title="Redo Last Undo" disabled>Redo</button>
             </div>

             <div id="effectOptionsContainer" class="effect-options">
                <div id="intensityControl" class="effect-option-group">
                     <div>
                         <label for="intensitySlider">Intensity/Max Iter:</label> <input type="range" id="intensitySlider" min="1" max="200" value="50"> <span id="intensityValue">50</span>
                     </div>
                </div>

                <div id="waveDistortionOptions" class="effect-option-group hidden">
                     <div class="effect-option-label">Wave Distortion Options</div>
                     <div>
                         <label for="waveAmplitudeSlider">Amplitude:</label>
                         <input type="range" id="waveAmplitudeSlider" min="0" max="50" value="10"> <span id="waveAmplitudeValue">10</span>
                     </div>
                      <div>
                         <label for="waveFrequencySlider">Frequency:</label>
                         <input type="range" id="waveFrequencySlider" min="1" max="50" value="5"> <span id="waveFrequencyValue">5</span>
                     </div>
                     <div> <label for="wavePhaseSlider">Phase Shift:</label>
                         <input type="range" id="wavePhaseSlider" min="0" max="360" value="0"> <span id="wavePhaseValue">0&deg;</span>
                     </div>
                     <div>
                         <label for="waveDirection">Direction:</label>
                         <select id="waveDirection">
                             <option value="horizontal" selected>Horizontal</option>
                             <option value="vertical">Vertical</option>
                             <option value="both">Both</option> </select>
                     </div>
                     <div>
                         <label for="waveType">Type:</label>
                         <select id="waveType">
                             <option value="sine" selected>Sine</option>
                             <option value="cosine">Cosine</option>
                         </select>
                     </div>
                 </div>
                 </div>
             <p id="realtimeWarning" class="hidden">Real-time preview disabled for this effect.</p>

             <div class="control-row">
                 <label for="saveWidth">Save Width:</label>
                 <input type="number" id="saveWidth" min="1" placeholder="Width" disabled>
                 <label for="saveHeight">Height:</label>
                 <input type="number" id="saveHeight" min="1" placeholder="Height" disabled>
                 <input type="checkbox" id="keepAspectRatio" disabled>
                 <label for="keepAspectRatio">Keep Aspect Ratio</label>
             </div>

             <div class="control-row">
                 <button id="applyEffectButton" class="text-white font-medium py-2 px-4 shadow" title="Apply effect permanently (allows stacking)" disabled>
                     Apply Effect
                 </button>
                 <button id="resetButton" class="text-white font-medium py-2 px-4 shadow" title="Reset image to its original state" disabled>
                     Reset Image
                 </button>
                 <button id="saveButton" class="text-white font-medium py-2 px-4 shadow" title="Save the current image" disabled>
                     Save Image
                 </button>
             </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const imageLoader = document.getElementById('imageLoader');
        const imageCanvas = document.getElementById('imageCanvas');
        const canvasPlaceholder = document.getElementById('canvasPlaceholder');
        const canvasContainer = document.getElementById('canvasContainer');
        const fileNameDisplay = document.getElementById('fileName');
        const controlsDiv = document.getElementById('controls');
        const effectSelector = document.getElementById('effectSelector');
        const effectOptionsContainer = document.getElementById('effectOptionsContainer');
        const realtimeWarning = document.getElementById('realtimeWarning');
        const saveWidthInput = document.getElementById('saveWidth');
        const saveHeightInput = document.getElementById('saveHeight');
        const keepAspectRatioCheckbox = document.getElementById('keepAspectRatio');
        const zoomControlsDiv = document.getElementById('zoomControls');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const zoomResetButton = document.getElementById('zoomResetButton');
        const zoomInButton = document.getElementById('zoomInButton');
        const applyEffectButton = document.getElementById('applyEffectButton');
        const resetButton = document.getElementById('resetButton');
        const saveButton = document.getElementById('saveButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const ctx = imageCanvas.getContext('2d', { willReadFrequently: true });

        // --- Effect Option References ---
        const intensityControl = document.getElementById('intensityControl');
        const intensitySlider = document.getElementById('intensitySlider');
        const intensityValue = document.getElementById('intensityValue');

        const waveDistortionOptions = document.getElementById('waveDistortionOptions');
        const waveAmplitudeSlider = document.getElementById('waveAmplitudeSlider');
        const waveAmplitudeValue = document.getElementById('waveAmplitudeValue');
        const waveFrequencySlider = document.getElementById('waveFrequencySlider');
        const waveFrequencyValue = document.getElementById('waveFrequencyValue');
        const wavePhaseSlider = document.getElementById('wavePhaseSlider');
        const wavePhaseValue = document.getElementById('wavePhaseValue');
        const waveDirection = document.getElementById('waveDirection');
        const waveType = document.getElementById('waveType');

        // --- State Variables ---
        let originalImageData = null;
        let currentImage = null;
        let currentImageAspectRatio = 1;
        let currentFileName = 'image.png';
        let isRealtimeUpdatePending = false;
        let lastAppliedImageData = null;
        const drawingEffects = ['fractalZoom', 'juliaSet']; // Added juliaSet
        let currentZoomLevel = 1.0;
        const MAX_ZOOM = 5.0;
        const MIN_ZOOM = 0.1;
        const ZOOM_STEP = 0.2;
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 10;

        // --- Helper Functions ---
        function resetUI(isLoaded = false) {
            fileNameDisplay.textContent = isLoaded ? `Selected: ${currentFileName}` : 'No image selected';
            controlsDiv.classList.toggle('hidden', !isLoaded);
            zoomControlsDiv.classList.toggle('hidden', !isLoaded);
            const allControls = controlsDiv.querySelectorAll('button, select, input');
            allControls.forEach(el => el.disabled = !isLoaded);
            zoomControlsDiv.querySelectorAll('button').forEach(el => el.disabled = !isLoaded);
            if (isLoaded) {
                imageCanvas.classList.remove('hidden'); canvasPlaceholder.classList.add('hidden');
                saveWidthInput.value = imageCanvas.width; saveHeightInput.value = imageCanvas.height;
                currentImageAspectRatio = imageCanvas.width / imageCanvas.height;
                resetZoom(); clearHistory(); pushHistoryState(originalImageData);
                updateVisibleControls();
            } else {
                imageCanvas.classList.add('hidden'); canvasPlaceholder.classList.remove('hidden');
                canvasPlaceholder.textContent = 'Image will appear here';
                if (imageCanvas.width > 0 && imageCanvas.height > 0) ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                currentImage = null; originalImageData = null; lastAppliedImageData = null;
                saveWidthInput.value = ''; saveHeightInput.value = '';
                keepAspectRatioCheckbox.checked = false; currentImageAspectRatio = 1;
                resetZoom(); clearHistory();
                effectSelector.value = 'noise'; // Default to a simple effect
                updateVisibleControls();
            }
             // Reset specific controls to defaults if not loaded
            if (!isLoaded) {
                 waveAmplitudeSlider.value = 10; waveAmplitudeValue.textContent = 10;
                 waveFrequencySlider.value = 5; waveFrequencyValue.textContent = 5;
                 wavePhaseSlider.value = 0; wavePhaseValue.textContent = '0°';
                 waveDirection.value = 'horizontal';
                 waveType.value = 'sine';
                 intensitySlider.value = 50; intensityValue.textContent = 50; // Reset generic slider too
            }
            updateUndoRedoButtons();
        }

        function resetImageToOriginal() {
            if (originalImageData) {
                ctx.putImageData(originalImageData, 0, 0);
                lastAppliedImageData = new ImageData( new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height );
                clearHistory(); pushHistoryState(originalImageData);
                console.log("Image reset to original.");
            } else { alert("No original image data found to reset to."); }
        }

        // --- Update Visible Controls ---
        function updateVisibleControls() {
            const selectedEffect = effectSelector.value;
            // Hide all specific option groups first
            effectOptionsContainer.querySelectorAll('.effect-option-group').forEach(el => el.classList.add('hidden'));

            // Show the relevant group
            if (selectedEffect === 'waveDistortion') {
                waveDistortionOptions.classList.remove('hidden');
            } else {
                 // Show generic intensity slider for effects that use it
                 const usesGenericIntensity = ['noise', 'scanLines', 'fractalZoom', 'juliaSet']; // Added juliaSet
                 intensityControl.classList.toggle('hidden', !usesGenericIntensity.includes(selectedEffect));
                 // Update generic slider label based on effect
                 const intensityLabel = intensityControl.querySelector('label');
                 if (selectedEffect === 'fractalZoom' || selectedEffect === 'juliaSet') {
                     intensityLabel.textContent = 'Intensity/Max Iter:';
                     intensitySlider.max = 200; // Increase max for Julia Set iterations
                 } else {
                     intensityLabel.textContent = 'Intensity:';
                     intensitySlider.max = 100; // Default max
                 }
                 intensityValue.textContent = intensitySlider.value; // Update display
            }
            // Show/hide real-time warning
            realtimeWarning.classList.toggle('hidden', !drawingEffects.includes(selectedEffect));
        }


        // --- Aspect Ratio Logic ---
        function handleDimensionChange(changedInput) {
            if (!keepAspectRatioCheckbox.checked || !currentImageAspectRatio || currentImageAspectRatio === 0) return;
            const widthVal = parseInt(saveWidthInput.value, 10); const heightVal = parseInt(saveHeightInput.value, 10);
            if (changedInput === 'width' && !isNaN(widthVal) && widthVal > 0) { saveHeightInput.value = Math.round(widthVal / currentImageAspectRatio); }
            else if (changedInput === 'height' && !isNaN(heightVal) && heightVal > 0) { saveWidthInput.value = Math.round(heightVal * currentImageAspectRatio); }
        }
        saveWidthInput.addEventListener('input', () => handleDimensionChange('width'));
        saveHeightInput.addEventListener('input', () => handleDimensionChange('height'));

        // --- Zoom Logic ---
        function applyZoom() { imageCanvas.style.transform = `scale(${currentZoomLevel})`; zoomOutButton.disabled = currentZoomLevel <= MIN_ZOOM; zoomInButton.disabled = currentZoomLevel >= MAX_ZOOM; zoomResetButton.disabled = currentZoomLevel === 1.0; }
        function resetZoom() { currentZoomLevel = 1.0; applyZoom(); }
        zoomInButton.addEventListener('click', () => { currentZoomLevel = Math.min(MAX_ZOOM, currentZoomLevel + ZOOM_STEP); applyZoom(); });
        zoomOutButton.addEventListener('click', () => { currentZoomLevel = Math.max(MIN_ZOOM, currentZoomLevel - ZOOM_STEP); applyZoom(); });
        zoomResetButton.addEventListener('click', resetZoom);

        // --- Undo/Redo Logic ---
        function clearHistory() { history = []; historyIndex = -1; updateUndoRedoButtons(); }
        function pushHistoryState(imageData) { if (!imageData) return; if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); } if (history.length >= MAX_HISTORY) { history.shift(); } else { historyIndex++; } history.push(new ImageData( new Uint8ClampedArray(imageData.data), imageData.width, imageData.height )); historyIndex = history.length - 1; console.log(`History push: size=${history.length}, index=${historyIndex}`); updateUndoRedoButtons(); }
        function updateUndoRedoButtons() { undoButton.disabled = historyIndex <= 0; redoButton.disabled = historyIndex >= history.length - 1; }
        function undo() { if (historyIndex > 0) { historyIndex--; const previousState = history[historyIndex]; ctx.putImageData(previousState, 0, 0); lastAppliedImageData = new ImageData( new Uint8ClampedArray(previousState.data), previousState.width, previousState.height ); console.log(`Undo: index=${historyIndex}`); updateUndoRedoButtons(); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; const nextState = history[historyIndex]; ctx.putImageData(nextState, 0, 0); lastAppliedImageData = new ImageData( new Uint8ClampedArray(nextState.data), nextState.width, nextState.height ); console.log(`Redo: index=${historyIndex}`); updateUndoRedoButtons(); } }
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // --- Image Loading Logic ---
        imageLoader.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files && files[0]) {
                const file = files[0]; currentFileName = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    currentImage = new Image();
                    currentImage.onload = () => {
                        const MAX_WIDTH = 800; const MAX_HEIGHT = 800; let width = currentImage.naturalWidth; let height = currentImage.naturalHeight;
                        if (width > MAX_WIDTH || height > MAX_HEIGHT) { const ratio = Math.min(MAX_WIDTH / width, MAX_HEIGHT / height); width = Math.round(width * ratio); height = Math.round(height * ratio); console.log(`Resized image to ${width}x${height} for performance.`); }
                        imageCanvas.width = width; imageCanvas.height = height; ctx.drawImage(currentImage, 0, 0, width, height);
                        try { originalImageData = ctx.getImageData(0, 0, width, height); lastAppliedImageData = new ImageData( new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height ); resetUI(true); }
                        catch (error) { console.error("Error getting initial image data:", error); alert("Could not process image data. Ensure the image is from a valid source and not cross-origin restricted."); resetUI(false); }
                    };
                    currentImage.onerror = () => { console.error("Error loading the image."); alert("Could not load the selected image file."); resetUI(false); };
                    currentImage.src = e.target.result;
                };
                reader.onerror = () => { console.error("Error reading the file."); alert("Could not read the selected file."); resetUI(false); };
                reader.readAsDataURL(file);
            } else { resetUI(false); }
        });

        // --- Real-time Update Logic ---
        function requestRealtimeUpdate() { if (drawingEffects.includes(effectSelector.value)) return; if (!isRealtimeUpdatePending && originalImageData) { isRealtimeUpdatePending = true; requestAnimationFrame(handleRealtimeUpdate); } }
        function handleRealtimeUpdate() {
            isRealtimeUpdatePending = false; if (!lastAppliedImageData) return;
            const imageData = new ImageData( new Uint8ClampedArray(lastAppliedImageData.data), lastAppliedImageData.width, lastAppliedImageData.height );
            const { effect, params } = getCurrentEffectAndParams();
            applyEffectLogic(imageData, effect, params);
            ctx.putImageData(imageData, 0, 0);
        }

        // --- Slider Value Display & Real-time Trigger ---
        function setupSliderListener(slider, valueDisplay, isRealtime = true, formatter = val => val) {
             slider.addEventListener('input', () => {
                 valueDisplay.textContent = formatter(slider.value);
                 if(isRealtime) requestRealtimeUpdate();
             });
             // Initial formatting
             valueDisplay.textContent = formatter(slider.value);
        }
        // Generic Intensity/Depth
        setupSliderListener(intensitySlider, intensityValue, !drawingEffects.includes(effectSelector.value));
        // Wave Distortion Sliders
        setupSliderListener(waveAmplitudeSlider, waveAmplitudeValue, true);
        setupSliderListener(waveFrequencySlider, waveFrequencyValue, true);
        setupSliderListener(wavePhaseSlider, wavePhaseValue, true, val => val + '°');

        // --- Effect Selection Change ---
        effectSelector.addEventListener('change', () => {
             updateVisibleControls();
             // Re-setup listener for intensity slider based on whether the NEW effect is real-time
             setupSliderListener(intensitySlider, intensityValue, !drawingEffects.includes(effectSelector.value));
             if (drawingEffects.includes(effectSelector.value)) {
                 if(lastAppliedImageData) { ctx.putImageData(lastAppliedImageData, 0, 0); } // Reset view for drawing effects
             } else {
                 requestRealtimeUpdate(); // Apply effect if real-time enabled
             }
        });
        // Add change listeners for new dropdowns to trigger real-time update
        waveDirection.addEventListener('change', requestRealtimeUpdate);
        waveType.addEventListener('change', requestRealtimeUpdate);


        // --- Get Current Parameters ---
        function getCurrentEffectAndParams() {
            const effect = effectSelector.value;
            const params = {
                intensity: parseInt(intensitySlider.value, 10) // Generic intensity/maxIter
            };

            switch(effect) {
                case 'waveDistortion':
                    params.amplitude = parseInt(waveAmplitudeSlider.value, 10);
                    params.frequency = parseInt(waveFrequencySlider.value, 10);
                    params.phase = parseInt(wavePhaseSlider.value, 10) * (Math.PI / 180); // Convert degrees to radians
                    params.direction = waveDirection.value;
                    params.waveType = waveType.value;
                    break;
                 case 'scanLines': // Example if scanlines options were kept
                     // params.intensity = parseInt(scanLinesIntensitySlider.value, 10);
                     // params.direction = scanLinesDirection.value; // Uncomment if scanLines options are present
                     // params.thickness = parseInt(scanLinesThicknessSlider.value, 10);
                     break;
                 // Add cases for other effects with specific options
                 case 'fractalZoom': // Uses generic intensity slider
                 case 'juliaSet':    // Uses generic intensity slider for max iterations
                    break;
            }
            return { effect, params };
        }


        // --- Core Effect Application Logic ---
        function applyEffectLogic(imageData, effect, params) {
             switch (effect) {
                case 'noise': applyNoise(imageData, params.intensity); break;
                case 'scanLines': applyScanLines(imageData, params.intensity); break; // Pass full params if options kept
                case 'waveDistortion': applyWaveDistortion(imageData, params.amplitude, params.frequency, params.phase, params.direction, params.waveType); break;
                case 'fractalZoom': applyFractalZoom(imageData, params.intensity); break;
                case 'juliaSet': applyJuliaSet(imageData, params.intensity); break; // New
                // Add other cases if effects were kept
            }
        }

        // --- Apply Effect Button (Commits the effect) ---
        applyEffectButton.addEventListener('click', () => {
            if (!originalImageData) { alert("Load an image first!"); return; }
            const { effect, params } = getCurrentEffectAndParams();
            let imageDataToModify = new ImageData( new Uint8ClampedArray(lastAppliedImageData.data), lastAppliedImageData.width, lastAppliedImageData.height );
            if (drawingEffects.includes(effect)) { ctx.putImageData(lastAppliedImageData, 0, 0); } // Reset canvas for drawing effects
            applyEffectLogic(imageDataToModify, effect, params);
            if (!drawingEffects.includes(effect)) { ctx.putImageData(imageDataToModify, 0, 0); }
            let finalImageData;
            try { finalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height); }
            catch (e) { console.error("Error getting final image data after apply:", e); alert("Could not finalize the effect due to a canvas read error."); resetImageToOriginal(); return; }
            lastAppliedImageData = finalImageData; pushHistoryState(finalImageData);
            console.log(`Effect ${effect} applied permanently.`);
        });

        // --- Reset Button ---
        resetButton.addEventListener('click', resetImageToOriginal);

        // --- Save Button ---
        saveButton.addEventListener('click', () => {
            if (!currentImage || !lastAppliedImageData) { alert("No image loaded or processed to save."); return; }
            let saveWidth = parseInt(saveWidthInput.value, 10); let saveHeight = parseInt(saveHeightInput.value, 10);
            if (isNaN(saveWidth) || saveWidth <= 0) { saveWidth = imageCanvas.width; console.warn("Invalid save width, using current canvas width."); saveWidthInput.value = saveWidth; }
            if (isNaN(saveHeight) || saveHeight <= 0) { saveHeight = imageCanvas.height; console.warn("Invalid save height, using current canvas height."); saveHeightInput.value = saveHeight; }
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = saveWidth; tempCanvas.height = saveHeight; const tempCtx = tempCanvas.getContext('2d');
            if (!tempCtx) { alert("Could not create temporary canvas context for saving."); return; }
            tempCtx.imageSmoothingEnabled = true; tempCtx.imageSmoothingQuality = 'high';
            tempCtx.drawImage(imageCanvas, 0, 0, imageCanvas.width, imageCanvas.height, 0, 0, saveWidth, saveHeight);
            const link = document.createElement('a'); const baseName = currentFileName.substring(0, currentFileName.lastIndexOf('.')) || 'download';
            link.download = `${baseName}-effect-${saveWidth}x${saveHeight}.png`;
            try { link.href = tempCanvas.toDataURL('image/png'); link.click(); link.remove(); }
            catch (error) { console.error("Error saving image:", error); alert("Could not save the image. This might be due to canvas security restrictions or size limitations."); }
        });

        // --- Effect Implementation Functions ---

        // Effect: Noise
        function applyNoise(imageData, intensity) { const data = imageData.data; const width = imageData.width; const height = imageData.height; const noiseAmount = Math.round(255 * (intensity / 100) * 0.5); for (let i = 0; i < data.length; i += 4) { const noise = Math.round((Math.random() - 0.5) * 2 * noiseAmount); data[i]=Math.max(0, Math.min(255, data[i]+noise)); data[i+1]=Math.max(0, Math.min(255, data[i+1]+noise)); data[i+2]=Math.max(0, Math.min(255, data[i+2]+noise)); } }
        // Effect: Scan Lines (Simplified version)
        function applyScanLines(imageData, intensity, direction = 'horizontal', thickness = 2) { const data = imageData.data; const width = imageData.width; const height = imageData.height; const darknessFactor = intensity / 100; const lineThickness = Math.max(1, thickness); if (direction === 'horizontal') { for (let y = 0; y < height; y += (lineThickness * 2)) { for (let lineY = y; lineY < Math.min(y + lineThickness, height); lineY++) { for (let x = 0; x < width; x++) { const index = (lineY * width + x) * 4; data[index]=Math.max(0, data[index]*(1-darknessFactor)); data[index+1]=Math.max(0, data[index+1]*(1-darknessFactor)); data[index+2]=Math.max(0, data[index+2]*(1-darknessFactor)); } } } } else { for (let x = 0; x < width; x += (lineThickness * 2)) { for (let lineX = x; lineX < Math.min(x + lineThickness, width); lineX++) { for (let y = 0; y < height; y++) { const index = (y * width + lineX) * 4; data[index]=Math.max(0, data[index]*(1-darknessFactor)); data[index+1]=Math.max(0, data[index+1]*(1-darknessFactor)); data[index+2]=Math.max(0, data[index+2]*(1-darknessFactor)); } } } } }

        // Effect: Wave Distortion (UPDATED with phase)
        function applyWaveDistortion(imageData, amplitude = 10, frequency = 5, phase = 0, direction = 'horizontal', waveType = 'sine') {
            const data = imageData.data; // Target data array to modify
            const width = imageData.width; const height = imageData.height;
            const sourceImageData = lastAppliedImageData ? lastAppliedImageData : originalImageData;
            if (!sourceImageData) { console.error("Source image data not available for wave."); return; }
            const sourceData = sourceImageData.data;
            const destinationData = new Uint8ClampedArray(data.length); // Write results here
            const freqCycles = 2 + (18 * (frequency / 50)); const freqScale = (Math.PI * 2) * freqCycles;
            function getInterpolatedPixel(x, y) { const x_floor = Math.floor(x); const y_floor = Math.floor(y); const x_frac = x - x_floor; const y_frac = y - y_floor; const index1 = (y_floor * width + x_floor) * 4; const index2 = (y_floor * width + (x_floor + 1)) * 4; const index3 = ((y_floor + 1) * width + x_floor) * 4; const index4 = ((y_floor + 1) * width + (x_floor + 1)) * 4; const pixel = [0, 0, 0, 0]; for (let i = 0; i < 4; i++) { const p1 = (index1 + i >= 0 && index1 + i < sourceData.length) ? sourceData[index1 + i] : 0; const p2 = (index2 + i >= 0 && index2 + i < sourceData.length) ? sourceData[index2 + i] : 0; const p3 = (index3 + i >= 0 && index3 + i < sourceData.length) ? sourceData[index3 + i] : 0; const p4 = (index4 + i >= 0 && index4 + i < sourceData.length) ? sourceData[index4 + i] : 0; const topInterpolation = p1 * (1 - x_frac) + p2 * x_frac; const bottomInterpolation = p3 * (1 - x_frac) + p4 * x_frac; pixel[i] = Math.round(topInterpolation * (1 - y_frac) + bottomInterpolation * y_frac); } return pixel; }
            const waveFunc = (waveType === 'cosine') ? Math.cos : Math.sin;
            for (let py = 0; py < height; py++) { for (let px = 0; px < width; px++) { let sx = px; let sy = py; let xOffset = 0; let yOffset = 0; if (direction === 'horizontal' || direction === 'both') { xOffset = amplitude * waveFunc((py / height) * freqScale + phase); sx = px + xOffset; } if (direction === 'vertical' || direction === 'both') { yOffset = amplitude * waveFunc((px / width) * freqScale + phase); sy = py + yOffset; } const [r, g, b, a] = getInterpolatedPixel(sx, sy); const targetIndex = (py * width + px) * 4; destinationData[targetIndex] = r; destinationData[targetIndex + 1] = g; destinationData[targetIndex + 2] = b; destinationData[targetIndex + 3] = a; } }
            data.set(destinationData);
        }

        // Effect: Fractal Zoom (REVISED v7 - Inverse Map Iterative)
        function applyFractalZoom(imageData, intensity) {
            const data = imageData.data; // Target data array to modify
            const width = imageData.width; const height = imageData.height;
            const maxDepth = Math.max(1, Math.min(5, Math.round(intensity / 20)));
            const zoomFactor = ((intensity - 1) / 99.0) * 1.6 - 0.8; // Range ~ -0.8 to +0.8
            const sourceImageData = lastAppliedImageData ? lastAppliedImageData : originalImageData;
            if (!sourceImageData) { console.error("Source image data not available for zoom."); return; }
            const sourceData = sourceImageData.data;
            const destinationData = new Uint8ClampedArray(data.length); // Write results here
            function getInterpolatedPixel(x, y) { const x_floor = Math.floor(x); const y_floor = Math.floor(y); const x_frac = x - x_floor; const y_frac = y - y_floor; const index1 = (y_floor * width + x_floor) * 4; const index2 = (y_floor * width + (x_floor + 1)) * 4; const index3 = ((y_floor + 1) * width + x_floor) * 4; const index4 = ((y_floor + 1) * width + (x_floor + 1)) * 4; const pixel = [0, 0, 0, 0]; for (let i = 0; i < 4; i++) { const p1 = (index1 + i >= 0 && index1 + i < sourceData.length) ? sourceData[index1 + i] : 0; const p2 = (index2 + i >= 0 && index2 + i < sourceData.length) ? sourceData[index2 + i] : 0; const p3 = (index3 + i >= 0 && index3 + i < sourceData.length) ? sourceData[index3 + i] : 0; const p4 = (index4 + i >= 0 && index4 + i < sourceData.length) ? sourceData[index4 + i] : 0; const topInterpolation = p1 * (1 - x_frac) + p2 * x_frac; const bottomInterpolation = p3 * (1 - x_frac) + p4 * x_frac; pixel[i] = Math.round(topInterpolation * (1 - y_frac) + bottomInterpolation * y_frac); } return pixel; }
            for (let py = 0; py < height; py++) { for (let px = 0; px < width; px++) { let sx = px; let sy = py; for (let depth = 1; depth <= maxDepth; depth++) { const levelFactor = 2 ** (depth - 1); const segmentSizeW = width / levelFactor; const segmentSizeH = height / levelFactor; const qx = Math.floor(sx / segmentSizeW) * segmentSizeW; const qy = Math.floor(sy / segmentSizeH) * segmentSizeH; const centerX = qx + segmentSizeW / 2; const centerY = qy + segmentSizeH / 2; const dx = sx - centerX; const dy = sy - centerY; const scale = 1.0 + zoomFactor / depth; if (scale !== 0) { sx = centerX + dx / scale; sy = centerY + dy / scale; } } const [r, g, b, a] = getInterpolatedPixel(sx, sy); const targetIndex = (py * width + px) * 4; destinationData[targetIndex] = r; destinationData[targetIndex + 1] = g; destinationData[targetIndex + 2] = b; destinationData[targetIndex + 3] = a; } }
            data.set(destinationData);
        }

        // Effect: Julia Set (NEW)
        function applyJuliaSet(imageData, maxIterations) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Julia Constant (c) - A common visually interesting value
            const cx = -0.8;
            const cy = 0.156;

            // Complex plane mapping parameters
            const zoom = 1.0; // Adjust for zooming into the fractal
            const moveX = 0;
            const moveY = 0;

            // Color mapping function (simple gradient based on iterations)
            function mapColor(iterations, maxIter) {
                if (iterations === maxIter) return [0, 0, 0, 255]; // Black for points inside the set

                // Simple smooth coloring based on iteration count
                const t = iterations / maxIter;
                const r = Math.round(9 * (1 - t) * t * t * t * 255);
                const g = Math.round(15 * (1 - t) * (1 - t) * t * t * 255);
                const b = Math.round(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
                return [r, g, b, 255];
            }


            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    // Map pixel coordinates to complex plane (z = zx + i*zy)
                    // Adjust range from [-1.5, 1.5] for x and [-1, 1] for y (common for Julia)
                    let zx = 1.5 * (2 * px - width) / (0.5 * zoom * width) + moveX;
                    let zy = 1.0 * (2 * py - height) / (0.5 * zoom * height) + moveY;

                    let iteration = 0;
                    // Iterate z = z^2 + c until it escapes or max iterations reached
                    while (zx * zx + zy * zy < 4 && iteration < maxIterations) { // Escape radius = 2 (magnitude squared < 4)
                        const xtemp = zx * zx - zy * zy + cx;
                        zy = 2 * zx * zy + cy;
                        zx = xtemp;
                        iteration++;
                    }

                    // Map iteration count to color
                    const [r, g, b, a] = mapColor(iteration, maxIterations);

                    // Set pixel color in the target imageData
                    const index = (py * width + px) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = a;
                }
            }
            // No need for destinationData as we modify imageData directly here
        }


        // --- Initial Setup ---
        updateVisibleControls(); // Set initial visibility of sliders

    </script>

</body>
</html>
```

Changes:

1.  **HTML:** Added "Julia Set" to the effect dropdown. Updated the generic slider label to "Intensity/Max Iter".
2.  **JavaScript:**
    * Added `'juliaSet'` to the `drawingEffects` array.
    * Added the `applyJuliaSet` function:
        * It takes `imageData` and `maxIterations` (from the intensity slider).
        * It defines a fixed Julia constant `c` (`cx`, `cy`).
        * It iterates through each pixel (`px`, `py`).
        * It maps the pixel coordinates to a point (`zx`, `zy`) in the complex plane.
        * It iterates the formula $z_{new} = z_{old}^2 + c$ up to `maxIterations` times, checking if the magnitude squared ($zx^2 + zy^2$) exceeds 4 (escape condition).
        * It uses a `mapColor` helper function to determine the pixel color based on the number of iterations it took to escape (or black if it didn't escape).
        * It writes the calculated color directly to the `imageData.data` array.
    * Updated `applyEffectLogic` to call `applyJuliaSet`.
    * Updated `updateVisibleControls` to adjust the generic slider label and `max` value when "Julia Set" is selected.

Select "Julia Set" from the dropdown, adjust the "Intensity/Max Iter" slider (higher values give more detail but take longer), and click "Apply Effec