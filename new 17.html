<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor with Enhanced Effects</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better appearance */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        /* Canvas Container for Zooming/Scrolling */
        #canvasContainer {
            max-width: 100%;
            max-height: 60vh; /* Limit initial height */
            overflow: auto; /* Enable scrollbars for zoom */
            margin: 1rem auto; /* Center container */
            border: 1px dashed #d1d5db; /* Gray-300 border */
            border-radius: 0.5rem;
            background-color: #f9fafb; /* Light gray background */
            display: flex; /* Needed for centering canvas inside */
            justify-content: center;
            align-items: center;
        }
        /* Canvas Styling */
        canvas {
            display: block; /* Remove extra space below canvas */
            border-radius: 0.25rem; /* Smaller radius inside container */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            image-rendering: pixelated; /* Better for seeing glitch effects */
            transform-origin: top left; /* Zoom from top-left */
            transition: transform 0.1s ease-out; /* Smooth zoom transition */
            max-width: none !important; /* Override Tailwind max-width for zoom */
        }
        /* Style buttons and controls */
        button, label, select, input[type="number"], input[type="checkbox"] {
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease, border-color 0.3s ease, box-shadow 0.1s ease;
            margin: 0 0.25rem; /* Add some space between elements */
            padding: 0.5rem 1rem; /* Consistent padding */
            border-radius: 0.5rem; /* Rounded corners */
            border: 1px solid #d1d5db; /* Gray-300 border */
            font-size: 0.875rem; /* Slightly smaller text */
            vertical-align: middle; /* Align elements nicely */
        }
         button, label[for="imageLoader"] { /* Buttons and file label need different base styles */
             border: 1px solid transparent;
             background-color: #6366f1; /* Default button color */
             color: white;
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
         }
         button:hover, label[for="imageLoader"]:hover {
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
         }
         label[for="imageLoader"] { background-color: #3b82f6; } /* Blue for load */
         label[for="imageLoader"]:hover { background-color: #2563eb; }
         #applyEffectButton { background-color: #a855f7; } /* Purple */
         #applyEffectButton:hover { background-color: #9333ea; }
         #resetButton { background-color: #f59e0b; } /* Amber */
         #resetButton:hover { background-color: #d97706; }
         #saveButton { background-color: #22c55e; } /* Green */
         #saveButton:hover { background-color: #16a34a; }
         /* Specific styles for Undo/Redo/Zoom buttons */
         #undoButton, #redoButton, .zoom-button {
             background-color: #6b7280; /* Gray */
             padding: 0.4rem 0.8rem; /* Slightly smaller padding */
         }
         #undoButton:hover, #redoButton:hover, .zoom-button:hover {
             background-color: #4b5563;
         }

        button:active, label:active {
            transform: scale(0.98) translateY(1px); /* Slight shrink/press effect */
            box-shadow: none;
        }
        button:disabled, select:disabled, input[type="range"]:disabled, input[type="number"]:disabled, input[type="checkbox"]:disabled {
             opacity: 0.5;
             cursor: not-allowed;
             background-color: #e5e7eb !important; /* Lighter gray when disabled */
             color: #6b7280 !important;
             border-color: #d1d5db !important;
             box-shadow: none;
        }
        select {
            background-color: white;
            padding: 0.5rem 2rem 0.5rem 0.75rem; /* Adjust padding for dropdown arrow */
        }
        input[type="number"] {
             width: 80px; /* Fixed width for size inputs */
             text-align: right;
             padding-right: 0.5rem; /* Adjust padding */
              /* Prevent browser spinner arrows */
             -moz-appearance: textfield;
             appearance: textfield;
        }
         input[type="number"]::-webkit-outer-spin-button,
         input[type="number"]::-webkit-inner-spin-button {
             -webkit-appearance: none;
             margin: 0;
         }
         input[type="checkbox"] { /* Style checkbox */
             width: 1rem;
             height: 1rem;
             padding: 0;
             margin-right: 0.5rem; /* Space before label */
             border-radius: 0.25rem;
             accent-color: #6366f1; /* Match button color */
             border: 1px solid #d1d5db; /* Add border to checkbox */
         }

        input[type="range"] {
            cursor: pointer;
            width: 120px; /* Slightly wider slider */
            vertical-align: middle; /* Align slider nicely with text */
            accent-color: #6366f1; /* Indigo color for slider */
        }
        /* Hide the default file input visually but keep it accessible */
        input[type="file"] {
            width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1;
        }
        /* Container for controls */
        .controls-container {
            margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; /* Gray-200 separator */
            display: flex; flex-direction: column; align-items: center; gap: 1rem; /* Space between control rows */
        }
        .control-row {
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center;
            gap: 0.5rem 0.75rem; /* Row gap, Column gap */
            width: 100%; /* Ensure rows take full width for centering */
        }
        /* Specific container for effect parameters */
        .effect-options {
             display: flex;
             flex-direction: column; /* Stack option groups vertically */
             align-items: center; /* Center groups horizontally */
             gap: 1rem; /* Space between option groups */
             width: 100%;
             margin-top: 0.5rem; /* Space below effect selector */
             padding: 0.5rem;
             /* border: 1px dashed #ccc; */ /* Optional: for debugging layout */
        }
        .effect-option-group {
             display: flex;
             flex-wrap: wrap; /* Allow controls within a group to wrap */
             justify-content: center;
             align-items: center;
             gap: 0.5rem 1.5rem; /* More horizontal gap between parameter groups */
             width: 100%;
             padding-bottom: 0.5rem; /* Space below group */
             border-bottom: 1px dotted #e5e7eb; /* Dotted separator */
        }
         .effect-option-group:last-child {
             border-bottom: none; /* Remove border from last group */
         }

        .effect-option-group > div { /* Style individual parameter controls */
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .effect-option-label { /* Style for the group label */
             font-weight: 600;
             color: #4b5563; /* Gray-600 */
             margin-bottom: 0.5rem;
             width: 100%; /* Take full width */
             text-align: center;
             font-size: 0.9rem;
             padding-bottom: 0.25rem;
             /* border-bottom: 1px solid #e5e7eb; */ /* Separator below label */
        }


        .control-row label { /* General label styling */
            margin: 0; font-size: 0.875rem; color: #4b5563; font-weight: 500;
            border: none; padding: 0.5rem 0; background-color: transparent;
            white-space: nowrap; /* Prevent labels wrapping */
        }
         .control-row label[for="keepAspectRatio"] { /* Specific label for checkbox */
             padding: 0; /* Remove padding */
             margin-left: -0.25rem; /* Nudge closer to checkbox */
             user-select: none; /* Prevent text selection on click */
         }
        .control-row span { /* Slider value display */
             font-size: 0.875rem; color: #4b5563; min-width: 25px;
             text-align: right; font-family: monospace;
        }
        #realtimeWarning {
            font-size: 0.75rem; color: #ef4444; margin-top: -0.5rem;
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 md:p-8 rounded-lg shadow-lg w-full max-w-4xl text-center"> <h1 class="text-2xl md:text-3xl font-bold mb-6 text-gray-800">Image Editor with Effects, Resize, Zoom, Undo</h1>

        <div class="mb-4">
            <label for="imageLoader" class="inline-block text-white font-medium py-2 px-4 rounded-lg shadow">
                Load Image
            </label>
            <input type="file" id="imageLoader" name="imageLoader" accept="image/*" class="hidden"/>
            <p id="fileName" class="text-sm text-gray-500 mt-2">No image selected</p>
        </div>

        <div id="canvasContainer" class="mb-4 min-h-[200px]">
             <canvas id="imageCanvas" class="hidden"></canvas>
             <p id="canvasPlaceholder" class="text-gray-400">Image will appear here</p>
        </div>

         <div id="zoomControls" class="control-row mb-4 hidden">
             <label>Zoom:</label>
             <button id="zoomOutButton" class="zoom-button" title="Zoom Out" disabled>-</button>
             <button id="zoomResetButton" class="zoom-button" title="Reset Zoom" disabled>100%</button>
             <button id="zoomInButton" class="zoom-button" title="Zoom In" disabled>+</button>
        </div>

        <div id="controls" class="controls-container hidden">
             <div class="control-row">
                <label for="effectSelector">Effect:</label>
                <select id="effectSelector" class="shadow-sm">
                    <option value="sliceShift">Slice Shift</option>
                    <option value="pixelSort">Pixel Sort</option>
                    <option value="channelShift">Channel Shift</option>
                    <option value="blockDisplace">Block Displacement</option>
                    <option value="scanLines">Scan Lines</option>
                    <option value="noise">Noise</option>
                    <option value="invertBlocks">Invert Blocks/Circles</option>
                    <option value="recursiveDraw">Recursive Draw</option>
                    <option value="sierpinski">Sierpinski Carpet</option>
                    <option value="fractalTree">Fractal Tree</option>
                    <option value="recursiveShapes">Recursive Shapes</option> </select>
                <button id="undoButton" title="Undo Last Apply" disabled>Undo</button>
                <button id="redoButton" title="Redo Last Undo" disabled>Redo</button>
             </div>

             <div id="effectOptionsContainer" class="effect-options">

                <div id="intensityControl" class="effect-option-group">
                     <div> <label for="intensitySlider">Intensity/Depth:</label>
                        <input type="range" id="intensitySlider" min="1" max="100" value="30">
                        <span id="intensityValue">30</span>
                     </div>
                </div>

                <div id="sliceShiftOptions" class="effect-option-group hidden">
                     <div class="effect-option-label">Slice Shift Options</div>
                     <div>
                        <label for="sliceShiftDirection">Direction:</label>
                        <select id="sliceShiftDirection">
                            <option value="horizontal" selected>Horizontal</option>
                            <option value="vertical">Vertical</option>
                        </select>
                    </div>
                     <div>
                         <label for="sliceShiftIntensitySlider">Amount:</label>
                         <input type="range" id="sliceShiftIntensitySlider" min="1" max="100" value="30">
                         <span id="sliceShiftIntensityValue">30</span>
                     </div>
                </div>

                 <div id="pixelSortOptions" class="effect-option-group hidden">
                     <div class="effect-option-label">Pixel Sort Options</div>
                     <div>
                         <label for="pixelSortThresholdSlider">Threshold:</label>
                         <input type="range" id="pixelSortThresholdSlider" min="0" max="255" value="100">
                         <span id="pixelSortThresholdValue">100</span>
                     </div>
                     <div>
                         <label for="pixelSortDirection">Direction:</label>
                         <select id="pixelSortDirection">
                             <option value="horizontal" selected>Horizontal</option>
                             <option value="vertical">Vertical</option>
                         </select>
                     </div>
                     <div>
                         <label for="pixelSortBy">Sort By:</label>
                         <select id="pixelSortBy">
                             <option value="brightness" selected>Brightness</option>
                             <option value="hue">Hue</option>
                             <option value="saturation">Saturation</option>
                             <option value="red">Red</option>
                             <option value="green">Green</option>
                             <option value="blue">Blue</option>
                         </select>
                     </div>
                 </div>

                 <div id="scanLinesOptions" class="effect-option-group hidden">
                     <div class="effect-option-label">Scan Lines Options</div>
                     <div>
                         <label for="scanLinesIntensitySlider">Darkness:</label>
                         <input type="range" id="scanLinesIntensitySlider" min="0" max="100" value="50">
                         <span id="scanLinesIntensityValue">50</span>
                     </div>
                     <div>
                         <label for="scanLinesDirection">Direction:</label>
                         <select id="scanLinesDirection">
                             <option value="horizontal" selected>Horizontal</option>
                             <option value="vertical">Vertical</option>
                         </select>
                     </div>
                     <div>
                         <label for="scanLinesThicknessSlider">Thickness:</label>
                         <input type="range" id="scanLinesThicknessSlider" min="1" max="10" value="2">
                         <span id="scanLinesThicknessValue">2</span>
                     </div>
                 </div>

                 <div id="fractalTreeOptions" class="effect-option-group hidden">
                     <div class="effect-option-label">Fractal Tree Options</div>
                     <div>
                         <label for="fractalTreeDepthSlider">Depth:</label>
                         <input type="range" id="fractalTreeDepthSlider" min="2" max="12" value="7">
                         <span id="fractalTreeDepthValue">7</span>
                     </div>
                     <div>
                         <label for="fractalTreeAngleSlider">Angle Var:</label>
                         <input type="range" id="fractalTreeAngleSlider" min="5" max="90" value="30">
                         <span id="fractalTreeAngleValue">30&deg;</span>
                     </div>
                      <div>
                         <label for="fractalTreeLengthSlider">Length Factor:</label>
                         <input type="range" id="fractalTreeLengthSlider" min="50" max="90" value="75">
                         <span id="fractalTreeLengthValue">0.75</span>
                     </div>
                      <div>
                         <label for="fractalTreeWidthSlider">Line Width:</label>
                         <input type="range" id="fractalTreeWidthSlider" min="1" max="50" value="10"> <span id="fractalTreeWidthValue">1.0</span>
                     </div>
                 </div>

             </div>
             <p id="realtimeWarning" class="hidden">Real-time preview disabled for this effect.</p>

             <div class="control-row">
                 <label for="saveWidth">Save Width:</label>
                 <input type="number" id="saveWidth" min="1" placeholder="Width" disabled>
                 <label for="saveHeight">Height:</label>
                 <input type="number" id="saveHeight" min="1" placeholder="Height" disabled>
                 <input type="checkbox" id="keepAspectRatio" disabled>
                 <label for="keepAspectRatio">Keep Aspect Ratio</label>
             </div>

             <div class="control-row">
                 <button id="applyEffectButton" class="text-white font-medium py-2 px-4 shadow" title="Apply effect permanently (allows stacking)" disabled>
                     Apply Effect
                 </button>
                 <button id="resetButton" class="text-white font-medium py-2 px-4 shadow" title="Reset image to its original state" disabled>
                     Reset Image
                 </button>
                 <button id="saveButton" class="text-white font-medium py-2 px-4 shadow" title="Save the current image" disabled>
                     Save Image
                 </button>
             </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const imageLoader = document.getElementById('imageLoader');
        const imageCanvas = document.getElementById('imageCanvas');
        const canvasPlaceholder = document.getElementById('canvasPlaceholder');
        const canvasContainer = document.getElementById('canvasContainer');
        const fileNameDisplay = document.getElementById('fileName');
        const controlsDiv = document.getElementById('controls');
        const effectSelector = document.getElementById('effectSelector');
        const effectOptionsContainer = document.getElementById('effectOptionsContainer'); // Container for options
        const realtimeWarning = document.getElementById('realtimeWarning');
        const saveWidthInput = document.getElementById('saveWidth');
        const saveHeightInput = document.getElementById('saveHeight');
        const keepAspectRatioCheckbox = document.getElementById('keepAspectRatio');
        const zoomControlsDiv = document.getElementById('zoomControls');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const zoomResetButton = document.getElementById('zoomResetButton');
        const zoomInButton = document.getElementById('zoomInButton');
        const applyEffectButton = document.getElementById('applyEffectButton');
        const resetButton = document.getElementById('resetButton');
        const saveButton = document.getElementById('saveButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const ctx = imageCanvas.getContext('2d', { willReadFrequently: true });

        // --- Effect Option References ---
        const intensityControl = document.getElementById('intensityControl');
        const intensitySlider = document.getElementById('intensitySlider');
        const intensityValue = document.getElementById('intensityValue');

        const sliceShiftOptions = document.getElementById('sliceShiftOptions');
        const sliceShiftDirection = document.getElementById('sliceShiftDirection');
        const sliceShiftIntensitySlider = document.getElementById('sliceShiftIntensitySlider');
        const sliceShiftIntensityValue = document.getElementById('sliceShiftIntensityValue');

        const pixelSortOptions = document.getElementById('pixelSortOptions');
        const pixelSortThresholdSlider = document.getElementById('pixelSortThresholdSlider');
        const pixelSortThresholdValue = document.getElementById('pixelSortThresholdValue');
        const pixelSortDirection = document.getElementById('pixelSortDirection');
        const pixelSortBy = document.getElementById('pixelSortBy');

        const scanLinesOptions = document.getElementById('scanLinesOptions');
        const scanLinesIntensitySlider = document.getElementById('scanLinesIntensitySlider');
        const scanLinesIntensityValue = document.getElementById('scanLinesIntensityValue');
        const scanLinesDirection = document.getElementById('scanLinesDirection');
        const scanLinesThicknessSlider = document.getElementById('scanLinesThicknessSlider');
        const scanLinesThicknessValue = document.getElementById('scanLinesThicknessValue');

        const fractalTreeOptions = document.getElementById('fractalTreeOptions');
        const fractalTreeDepthSlider = document.getElementById('fractalTreeDepthSlider');
        const fractalTreeDepthValue = document.getElementById('fractalTreeDepthValue');
        const fractalTreeAngleSlider = document.getElementById('fractalTreeAngleSlider');
        const fractalTreeAngleValue = document.getElementById('fractalTreeAngleValue');
        const fractalTreeLengthSlider = document.getElementById('fractalTreeLengthSlider');
        const fractalTreeLengthValue = document.getElementById('fractalTreeLengthValue');
        const fractalTreeWidthSlider = document.getElementById('fractalTreeWidthSlider');
        const fractalTreeWidthValue = document.getElementById('fractalTreeWidthValue');

        // --- State Variables ---
        let originalImageData = null;
        let currentImage = null;
        let currentImageAspectRatio = 1;
        let currentFileName = 'image.png';
        let isRealtimeUpdatePending = false;
        let lastAppliedImageData = null;
        const drawingEffects = ['recursiveDraw', 'sierpinski', 'fractalTree', 'recursiveShapes']; // Added recursiveShapes back
        let currentZoomLevel = 1.0;
        const MAX_ZOOM = 5.0;
        const MIN_ZOOM = 0.1;
        const ZOOM_STEP = 0.2;
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 10;

        // --- Helper Functions ---
        function resetUI(isLoaded = false) {
            fileNameDisplay.textContent = isLoaded ? `Selected: ${currentFileName}` : 'No image selected';
            controlsDiv.classList.toggle('hidden', !isLoaded);
            zoomControlsDiv.classList.toggle('hidden', !isLoaded);
            // Disable all controls initially
            const allControls = controlsDiv.querySelectorAll('button, select, input');
            allControls.forEach(el => el.disabled = !isLoaded);
            zoomControlsDiv.querySelectorAll('button').forEach(el => el.disabled = !isLoaded);

            if (isLoaded) {
                imageCanvas.classList.remove('hidden'); canvasPlaceholder.classList.add('hidden');
                saveWidthInput.value = imageCanvas.width; saveHeightInput.value = imageCanvas.height;
                currentImageAspectRatio = imageCanvas.width / imageCanvas.height;
                resetZoom(); clearHistory(); pushHistoryState(originalImageData);
                updateVisibleControls(); // Show controls for the default effect
            } else {
                imageCanvas.classList.add('hidden'); canvasPlaceholder.classList.remove('hidden');
                canvasPlaceholder.textContent = 'Image will appear here';
                if (imageCanvas.width > 0 && imageCanvas.height > 0) ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                currentImage = null; originalImageData = null; lastAppliedImageData = null;
                saveWidthInput.value = ''; saveHeightInput.value = '';
                keepAspectRatioCheckbox.checked = false; currentImageAspectRatio = 1;
                resetZoom(); clearHistory();
                effectSelector.value = 'sliceShift'; // Reset dropdown
                updateVisibleControls(); // Hide all effect options
            }
            updateUndoRedoButtons();
        }

        function resetImageToOriginal() {
            if (originalImageData) {
                ctx.putImageData(originalImageData, 0, 0);
                lastAppliedImageData = new ImageData( new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height );
                clearHistory(); pushHistoryState(originalImageData);
                console.log("Image reset to original.");
            } else { alert("No original image data found to reset to."); }
        }

        // --- Update Visible Controls ---
        function updateVisibleControls() {
            const selectedEffect = effectSelector.value;
            // Hide all specific option groups first
            effectOptionsContainer.querySelectorAll('.effect-option-group').forEach(el => el.classList.add('hidden'));

            // Show the relevant group
            if (selectedEffect === 'sliceShift') {
                sliceShiftOptions.classList.remove('hidden');
            } else if (selectedEffect === 'pixelSort') {
                pixelSortOptions.classList.remove('hidden');
            } else if (selectedEffect === 'scanLines') {
                scanLinesOptions.classList.remove('hidden');
            } else if (selectedEffect === 'fractalTree') {
                fractalTreeOptions.classList.remove('hidden');
            } else {
                 // Show generic intensity slider for effects that use it and don't have specific options shown
                 const usesGenericIntensity = ['channelShift', 'blockDisplace', 'noise', 'invertBlocks', 'recursiveDraw', 'sierpinski', 'recursiveShapes']; // Added recursiveShapes back
                 intensityControl.classList.toggle('hidden', !usesGenericIntensity.includes(selectedEffect));
            }
            // Show/hide real-time warning
            realtimeWarning.classList.toggle('hidden', !drawingEffects.includes(selectedEffect));
        }


        // --- Aspect Ratio Logic ---
        function handleDimensionChange(changedInput) {
            if (!keepAspectRatioCheckbox.checked || !currentImageAspectRatio || currentImageAspectRatio === 0) return;
            const widthVal = parseInt(saveWidthInput.value, 10); const heightVal = parseInt(saveHeightInput.value, 10);
            if (changedInput === 'width' && !isNaN(widthVal) && widthVal > 0) { saveHeightInput.value = Math.round(widthVal / currentImageAspectRatio); }
            else if (changedInput === 'height' && !isNaN(heightVal) && heightVal > 0) { saveWidthInput.value = Math.round(heightVal * currentImageAspectRatio); }
        }
        saveWidthInput.addEventListener('input', () => handleDimensionChange('width'));
        saveHeightInput.addEventListener('input', () => handleDimensionChange('height'));

        // --- Zoom Logic ---
        function applyZoom() { imageCanvas.style.transform = `scale(${currentZoomLevel})`; zoomOutButton.disabled = currentZoomLevel <= MIN_ZOOM; zoomInButton.disabled = currentZoomLevel >= MAX_ZOOM; zoomResetButton.disabled = currentZoomLevel === 1.0; }
        function resetZoom() { currentZoomLevel = 1.0; applyZoom(); }
        zoomInButton.addEventListener('click', () => { currentZoomLevel = Math.min(MAX_ZOOM, currentZoomLevel + ZOOM_STEP); applyZoom(); });
        zoomOutButton.addEventListener('click', () => { currentZoomLevel = Math.max(MIN_ZOOM, currentZoomLevel - ZOOM_STEP); applyZoom(); });
        zoomResetButton.addEventListener('click', resetZoom);

        // --- Undo/Redo Logic ---
        function clearHistory() { history = []; historyIndex = -1; updateUndoRedoButtons(); }
        function pushHistoryState(imageData) { if (!imageData) return; if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); } if (history.length >= MAX_HISTORY) { history.shift(); } else { historyIndex++; } history.push(new ImageData( new Uint8ClampedArray(imageData.data), imageData.width, imageData.height )); historyIndex = history.length - 1; console.log(`History push: size=${history.length}, index=${historyIndex}`); updateUndoRedoButtons(); }
        function updateUndoRedoButtons() { undoButton.disabled = historyIndex <= 0; redoButton.disabled = historyIndex >= history.length - 1; }
        function undo() { if (historyIndex > 0) { historyIndex--; const previousState = history[historyIndex]; ctx.putImageData(previousState, 0, 0); lastAppliedImageData = new ImageData( new Uint8ClampedArray(previousState.data), previousState.width, previousState.height ); console.log(`Undo: index=${historyIndex}`); updateUndoRedoButtons(); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; const nextState = history[historyIndex]; ctx.putImageData(nextState, 0, 0); lastAppliedImageData = new ImageData( new Uint8ClampedArray(nextState.data), nextState.width, nextState.height ); console.log(`Redo: index=${historyIndex}`); updateUndoRedoButtons(); } }
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // --- Image Loading Logic ---
        imageLoader.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files && files[0]) {
                const file = files[0]; currentFileName = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    currentImage = new Image();
                    currentImage.onload = () => {
                        const MAX_WIDTH = 800; const MAX_HEIGHT = 800; let width = currentImage.naturalWidth; let height = currentImage.naturalHeight;
                        if (width > MAX_WIDTH || height > MAX_HEIGHT) { const ratio = Math.min(MAX_WIDTH / width, MAX_HEIGHT / height); width = Math.round(width * ratio); height = Math.round(height * ratio); console.log(`Resized image to ${width}x${height} for performance.`); }
                        imageCanvas.width = width; imageCanvas.height = height; ctx.drawImage(currentImage, 0, 0, width, height);
                        try { originalImageData = ctx.getImageData(0, 0, width, height); lastAppliedImageData = new ImageData( new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height ); resetUI(true); }
                        catch (error) { console.error("Error getting initial image data:", error); alert("Could not process image data. Ensure the image is from a valid source and not cross-origin restricted."); resetUI(false); }
                    };
                    currentImage.onerror = () => { console.error("Error loading the image."); alert("Could not load the selected image file."); resetUI(false); };
                    currentImage.src = e.target.result;
                };
                reader.onerror = () => { console.error("Error reading the file."); alert("Could not read the selected file."); resetUI(false); };
                reader.readAsDataURL(file);
            } else { resetUI(false); }
        });

        // --- Real-time Update Logic ---
        function requestRealtimeUpdate() { if (drawingEffects.includes(effectSelector.value)) return; if (!isRealtimeUpdatePending && originalImageData) { isRealtimeUpdatePending = true; requestAnimationFrame(handleRealtimeUpdate); } }
        function handleRealtimeUpdate() {
            isRealtimeUpdatePending = false; if (!lastAppliedImageData) return;
            const imageData = new ImageData( new Uint8ClampedArray(lastAppliedImageData.data), lastAppliedImageData.width, lastAppliedImageData.height );
            // Read current parameters based on selected effect
            const { effect, params } = getCurrentEffectAndParams();
            applyEffectLogic(imageData, effect, params); // Pass params object
            ctx.putImageData(imageData, 0, 0);
        }

        // --- Slider Value Display & Real-time Trigger ---
        function setupSliderListener(slider, valueDisplay, isRealtime = true, formatter = val => val) {
             slider.addEventListener('input', () => {
                 valueDisplay.textContent = formatter(slider.value);
                 if(isRealtime) requestRealtimeUpdate();
             });
        }
        // Generic Intensity/Depth
        setupSliderListener(intensitySlider, intensityValue);
        // Slice Shift
        setupSliderListener(sliceShiftIntensitySlider, sliceShiftIntensityValue);
        // Pixel Sort
        setupSliderListener(pixelSortThresholdSlider, pixelSortThresholdValue);
        // Scan Lines
        setupSliderListener(scanLinesIntensitySlider, scanLinesIntensityValue);
        setupSliderListener(scanLinesThicknessSlider, scanLinesThicknessValue);
        // Fractal Tree
        setupSliderListener(fractalTreeDepthSlider, fractalTreeDepthValue, false); // No real-time
        setupSliderListener(fractalTreeAngleSlider, fractalTreeAngleValue, false, val => val + 'Â°'); // No real-time
        setupSliderListener(fractalTreeLengthSlider, fractalTreeLengthValue, false, val => (val / 100).toFixed(2)); // No real-time
        setupSliderListener(fractalTreeWidthSlider, fractalTreeWidthValue, false, val => (val / 10).toFixed(1)); // No real-time


        // --- Effect Selection Change ---
        effectSelector.addEventListener('change', () => {
             updateVisibleControls();
             if (!drawingEffects.includes(effectSelector.value)) { requestRealtimeUpdate(); }
             else { if(lastAppliedImageData) { ctx.putImageData(lastAppliedImageData, 0, 0); } } // Reset view for drawing effects
        });

        // --- Get Current Parameters ---
        function getCurrentEffectAndParams() {
            const effect = effectSelector.value;
            const params = {};
            // Always include generic intensity for effects that might use it as fallback
            params.intensity = parseInt(intensitySlider.value, 10);

            switch(effect) {
                case 'sliceShift':
                    params.direction = sliceShiftDirection.value;
                    params.intensity = parseInt(sliceShiftIntensitySlider.value, 10); // Use specific slider
                    break;
                case 'pixelSort':
                    params.threshold = parseInt(pixelSortThresholdSlider.value, 10);
                    params.direction = pixelSortDirection.value;
                    params.sortBy = pixelSortBy.value;
                    break;
                case 'scanLines':
                    params.intensity = parseInt(scanLinesIntensitySlider.value, 10); // Darkness
                    params.direction = scanLinesDirection.value;
                    params.thickness = parseInt(scanLinesThicknessSlider.value, 10);
                    break;
                 case 'fractalTree':
                    params.depth = parseInt(fractalTreeDepthSlider.value, 10);
                    params.angleVariation = parseInt(fractalTreeAngleSlider.value, 10) * (Math.PI / 180); // Convert degrees to radians
                    params.lengthFactor = parseInt(fractalTreeLengthSlider.value, 10) / 100; // Convert percentage to factor
                    params.lineWidth = parseFloat(fractalTreeWidthSlider.value) / 10; // Convert scaled value
                    break;
                 // Effects using only generic intensity slider don't need specific entries here
                 // case 'channelShift':
                 // case 'blockDisplace':
                 // case 'noise':
                 // case 'invertBlocks':
                 // case 'recursiveDraw':
                 // case 'sierpinski':
                 // case 'recursiveShapes': // Ensure generic intensity is used if no specific options
                 //     params.intensity = parseInt(intensitySlider.value, 10); // Already included
                 //     break;
            }
            return { effect, params };
        }


        // --- Core Effect Application Logic ---
        function applyEffectLogic(imageData, effect, params) {
             // Note: For drawing effects, imageData is not directly used but context (ctx) is.
             switch (effect) {
                case 'sliceShift': applySliceShift(imageData, params.intensity, params.direction); break;
                case 'pixelSort': applyPixelSort(imageData, params.threshold, params.direction, params.sortBy); break;
                case 'channelShift': applyChannelShift(imageData, params.intensity); break;
                case 'blockDisplace': applyBlockDisplace(imageData, params.intensity); break;
                case 'scanLines': applyScanLines(imageData, params.intensity, params.direction, params.thickness); break;
                case 'noise': applyNoise(imageData, params.intensity); break;
                case 'invertBlocks': applyInvertBlocks(imageData, params.intensity); break;
                case 'recursiveDraw': if (currentImage) applyRecursiveDraw(ctx, currentImage, params.intensity); else console.error("Base image not available for recursive draw."); break;
                case 'sierpinski': applySierpinski(ctx, params.intensity); break; // Updated call
                case 'fractalTree': applyFractalTree(ctx, params.depth, params.angleVariation, params.lengthFactor, params.lineWidth); break;
                case 'recursiveShapes': applyRecursiveShapes(ctx, params.intensity); break; // Added back
            }
        }

        // --- Apply Effect Button (Commits the effect) ---
        applyEffectButton.addEventListener('click', () => {
            if (!originalImageData) { alert("Load an image first!"); return; }
            const { effect, params } = getCurrentEffectAndParams(); // Get current params
            let imageDataToModify = new ImageData( new Uint8ClampedArray(lastAppliedImageData.data), lastAppliedImageData.width, lastAppliedImageData.height );
            if (drawingEffects.includes(effect)) { ctx.putImageData(lastAppliedImageData, 0, 0); }
            applyEffectLogic(imageDataToModify, effect, params); // Pass params object
            if (!drawingEffects.includes(effect)) { ctx.putImageData(imageDataToModify, 0, 0); }
            let finalImageData;
            try { finalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height); }
            catch (e) { console.error("Error getting final image data after apply:", e); alert("Could not finalize the effect due to a canvas read error."); resetImageToOriginal(); return; }
            lastAppliedImageData = finalImageData; pushHistoryState(finalImageData);
            console.log(`Effect ${effect} applied permanently.`);
        });

        // --- Reset Button ---
        resetButton.addEventListener('click', resetImageToOriginal);

        // --- Save Button ---
        saveButton.addEventListener('click', () => {
            if (!currentImage || !lastAppliedImageData) { alert("No image loaded or processed to save."); return; }
            let saveWidth = parseInt(saveWidthInput.value, 10); let saveHeight = parseInt(saveHeightInput.value, 10);
            if (isNaN(saveWidth) || saveWidth <= 0) { saveWidth = imageCanvas.width; console.warn("Invalid save width, using current canvas width."); saveWidthInput.value = saveWidth; }
            if (isNaN(saveHeight) || saveHeight <= 0) { saveHeight = imageCanvas.height; console.warn("Invalid save height, using current canvas height."); saveHeightInput.value = saveHeight; }
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = saveWidth; tempCanvas.height = saveHeight; const tempCtx = tempCanvas.getContext('2d');
            if (!tempCtx) { alert("Could not create temporary canvas context for saving."); return; }
            console.log(`Drawing main canvas (${imageCanvas.width}x${imageCanvas.height}) to temp canvas (${saveWidth}x${saveHeight})`);
            tempCtx.imageSmoothingEnabled = true; tempCtx.imageSmoothingQuality = 'high';
            tempCtx.drawImage(imageCanvas, 0, 0, imageCanvas.width, imageCanvas.height, 0, 0, saveWidth, saveHeight);
            const link = document.createElement('a'); const baseName = currentFileName.substring(0, currentFileName.lastIndexOf('.')) || 'download';
            link.download = `${baseName}-effect-${saveWidth}x${saveHeight}.png`;
            try { link.href = tempCanvas.toDataURL('image/png'); link.click(); link.remove(); }
            catch (error) { console.error("Error saving image:", error); alert("Could not save the image. This might be due to canvas security restrictions or size limitations."); }
        });

        // --- Effect Implementation Functions ---
         // Effect 1: Slice Shift (UPDATED)
        function applySliceShift(imageData, intensity, direction = 'horizontal') { const data = imageData.data; const width = imageData.width; const height = imageData.height; const maxShift = Math.round((direction === 'horizontal' ? width : height) * (intensity / 100) * 0.3); const sliceSizeFactor = 1 + Math.round(10 * (intensity / 100)); const shiftProbability = 0.3 + (0.6 * (intensity / 100)); const sourceData = new Uint8ClampedArray(data); if (direction === 'horizontal') { for (let y = 0; y < height; y++) { if (Math.random() < shiftProbability) { const shiftAmount = Math.floor((Math.random() - 0.5) * 2 * maxShift); const sliceHeight = Math.floor(Math.random() * sliceSizeFactor) + 1; const sliceEndY = Math.min(y + sliceHeight, height); for (let sliceY = y; sliceY < sliceEndY; sliceY++) { for (let x = 0; x < width; x++) { const targetIndex = (sliceY * width + x) * 4; const sourceX = (x - shiftAmount + width) % width; const sourceIndex = (sliceY * width + sourceX) * 4; data[targetIndex]=sourceData[sourceIndex]; data[targetIndex+1]=sourceData[sourceIndex+1]; data[targetIndex+2]=sourceData[sourceIndex+2]; data[targetIndex+3]=sourceData[sourceIndex+3]; } } y = sliceEndY - 1; } } } else { for (let x = 0; x < width; x++) { if (Math.random() < shiftProbability) { const shiftAmount = Math.floor((Math.random() - 0.5) * 2 * maxShift); const sliceWidth = Math.floor(Math.random() * sliceSizeFactor) + 1; const sliceEndX = Math.min(x + sliceWidth, width); for (let sliceX = x; sliceX < sliceEndX; sliceX++) { for (let y = 0; y < height; y++) { const targetIndex = (y * width + sliceX) * 4; const sourceY = (y - shiftAmount + height) % height; const sourceIndex = (sourceY * width + sliceX) * 4; data[targetIndex]=sourceData[sourceIndex]; data[targetIndex+1]=sourceData[sourceIndex+1]; data[targetIndex+2]=sourceData[sourceIndex+2]; data[targetIndex+3]=sourceData[sourceIndex+3]; } } x = sliceEndX - 1; } } } }
        // Effect 2: Pixel Sort (UPDATED)
        function applyPixelSort(imageData, threshold, direction = 'horizontal', sortBy = 'brightness') { const data = imageData.data; const width = imageData.width; const height = imageData.height; function rgbToHsl(r, g, b) { r /= 255, g /= 255, b /= 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if (max === min) { h = s = 0; } else { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch(max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return [h, s, l]; } function getSortValue(r, g, b) { switch(sortBy) { case 'hue': return rgbToHsl(r, g, b)[0]; case 'saturation': return rgbToHsl(r, g, b)[1]; case 'red': return r; case 'green': return g; case 'blue': return b; case 'brightness': default: return 0.299 * r + 0.587 * g + 0.114 * b; } } if (direction === 'horizontal') { for (let y = 0; y < height; y++) { let currentRun = []; let startXOfRun = -1; for (let x = 0; x < width; x++) { const index = (y * width + x) * 4; const r = data[index], g = data[index+1], b = data[index+2]; const sortValue = getSortValue(r, g, b); const brightness = 0.299 * r + 0.587 * g + 0.114 * b; if (brightness < threshold) { if (currentRun.length === 0) startXOfRun = x; currentRun.push({ r, g, b, a: data[index+3], sortValue }); } else { if (currentRun.length > 1) { currentRun.sort((a, b) => a.sortValue - b.sortValue); for(let i=0; i<currentRun.length; i++) { const pixel = currentRun[i]; const targetIndex = (y * width + startXOfRun + i) * 4; data[targetIndex]=pixel.r; data[targetIndex+1]=pixel.g; data[targetIndex+2]=pixel.b; data[targetIndex+3]=pixel.a; } } currentRun = []; startXOfRun = -1; } } if (currentRun.length > 1) { currentRun.sort((a, b) => a.sortValue - b.sortValue); for(let i=0; i<currentRun.length; i++) { const pixel = currentRun[i]; const targetIndex = (y * width + startXOfRun + i) * 4; data[targetIndex]=pixel.r; data[targetIndex+1]=pixel.g; data[targetIndex+2]=pixel.b; data[targetIndex+3]=pixel.a; } } } } else { for (let x = 0; x < width; x++) { let currentRun = []; let startYOfRun = -1; for (let y = 0; y < height; y++) { const index = (y * width + x) * 4; const r = data[index], g = data[index+1], b = data[index+2]; const sortValue = getSortValue(r, g, b); const brightness = 0.299 * r + 0.587 * g + 0.114 * b; if (brightness < threshold) { if (currentRun.length === 0) startYOfRun = y; currentRun.push({ r, g, b, a: data[index+3], sortValue }); } else { if (currentRun.length > 1) { currentRun.sort((a, b) => a.sortValue - b.sortValue); for(let i=0; i<currentRun.length; i++) { const pixel = currentRun[i]; const targetIndex = ((startYOfRun + i) * width + x) * 4; data[targetIndex]=pixel.r; data[targetIndex+1]=pixel.g; data[targetIndex+2]=pixel.b; data[targetIndex+3]=pixel.a; } } currentRun = []; startYOfRun = -1; } } if (currentRun.length > 1) { currentRun.sort((a, b) => a.sortValue - b.sortValue); for(let i=0; i<currentRun.length; i++) { const pixel = currentRun[i]; const targetIndex = ((startYOfRun + i) * width + x) * 4; data[targetIndex]=pixel.r; data[targetIndex+1]=pixel.g; data[targetIndex+2]=pixel.b; data[targetIndex+3]=pixel.a; } } } } }
        // Effect 3: Channel Shift
        function applyChannelShift(imageData, intensity) { const data = imageData.data; const width = imageData.width; const height = imageData.height; const maxShift = Math.round(width * (intensity / 100) * 0.1); const shiftR = Math.floor((Math.random() - 0.5) * 2 * maxShift); const shiftG = Math.floor((Math.random() - 0.5) * 2 * maxShift); const shiftB = Math.floor((Math.random() - 0.5) * 2 * maxShift / 2); const sourceData = new Uint8ClampedArray(data); for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const index = (y * width + x) * 4; const xR = (x + shiftR + width) % width; const xG = (x + shiftG + width) % width; const xB = (x + shiftB + width) % width; const indexR = (y * width + xR) * 4; const indexG = (y * width + xG) * 4; const indexB = (y * width + xB) * 4; data[index]=sourceData[indexR]; data[index+1]=sourceData[indexG+1]; data[index+2]=sourceData[indexB+2]; data[index+3]=sourceData[index+3]; } } }
       // Effect 4: Block Displacement
        function applyBlockDisplace(imageData, intensity) { const data = imageData.data; const width = imageData.width; const height = imageData.height; const maxBlockSize = Math.max(5, Math.round(Math.min(width, height) * (intensity / 100) * 0.2)); const numBlocks = Math.round(10 + 190 * (intensity / 100)); for (let i = 0; i < numBlocks; i++) { const blockSize = Math.floor(Math.random() * (maxBlockSize - 3)) + 3; const x1 = Math.floor(Math.random() * (width - blockSize)); const y1 = Math.floor(Math.random() * (height - blockSize)); const x2 = Math.floor(Math.random() * (width - blockSize)); const y2 = Math.floor(Math.random() * (height - blockSize)); const block1Temp = []; const block2Temp = []; for (let by = 0; by < blockSize; by++) { for (let bx = 0; bx < blockSize; bx++) { const index1 = ((y1 + by) * width + (x1 + bx)) * 4; const index2 = ((y2 + by) * width + (x2 + bx)) * 4; block1Temp.push(data[index1], data[index1+1], data[index1+2], data[index1+3]); block2Temp.push(data[index2], data[index2+1], data[index2+2], data[index2+3]); } } let tempIndex = 0; for (let by = 0; by < blockSize; by++) { for (let bx = 0; bx < blockSize; bx++) { const index1 = ((y1 + by) * width + (x1 + bx)) * 4; const index2 = ((y2 + by) * width + (x2 + bx)) * 4; data[index1]=block2Temp[tempIndex]; data[index1+1]=block2Temp[tempIndex+1]; data[index1+2]=block2Temp[tempIndex+2]; data[index1+3]=block2Temp[tempIndex+3]; data[index2]=block1Temp[tempIndex]; data[index2+1]=block1Temp[tempIndex+1]; data[index2+2]=block1Temp[tempIndex+2]; data[index2+3]=block1Temp[tempIndex+3]; tempIndex += 4; } } } }
        // Effect 5: Scan Lines (UPDATED)
        function applyScanLines(imageData, intensity, direction = 'horizontal', thickness = 2) {
            const data = imageData.data; const width = imageData.width; const height = imageData.height;
            const darknessFactor = intensity / 100; // Intensity controls darkness
            const lineThickness = Math.max(1, thickness); // Ensure thickness is at least 1

            if (direction === 'horizontal') {
                for (let y = 0; y < height; y += (lineThickness * 2)) {
                     for (let lineY = y; lineY < Math.min(y + lineThickness, height); lineY++) {
                        for (let x = 0; x < width; x++) {
                            const index = (lineY * width + x) * 4;
                            data[index]=Math.max(0, data[index]*(1-darknessFactor));
                            data[index+1]=Math.max(0, data[index+1]*(1-darknessFactor));
                            data[index+2]=Math.max(0, data[index+2]*(1-darknessFactor));
                        }
                     }
                }
            } else { // Vertical
                 for (let x = 0; x < width; x += (lineThickness * 2)) {
                     for (let lineX = x; lineX < Math.min(x + lineThickness, width); lineX++) {
                        for (let y = 0; y < height; y++) {
                            const index = (y * width + lineX) * 4;
                             data[index]=Math.max(0, data[index]*(1-darknessFactor));
                             data[index+1]=Math.max(0, data[index+1]*(1-darknessFactor));
                             data[index+2]=Math.max(0, data[index+2]*(1-darknessFactor));
                        }
                     }
                }
            }
        }
        // Effect 6: Noise
        function applyNoise(imageData, intensity) { const data = imageData.data; const width = imageData.width; const height = imageData.height; const noiseAmount = Math.round(255 * (intensity / 100) * 0.5); for (let i = 0; i < data.length; i += 4) { const noise = Math.round((Math.random() - 0.5) * 2 * noiseAmount); data[i]=Math.max(0, Math.min(255, data[i]+noise)); data[i+1]=Math.max(0, Math.min(255, data[i+1]+noise)); data[i+2]=Math.max(0, Math.min(255, data[i+2]+noise)); } }
        // Effect 7: Invert Blocks/Circles
        function applyInvertBlocks(imageData, intensity) { const data = imageData.data; const width = imageData.width; const height = imageData.height; const maxBlockSize = Math.max(5, Math.round(Math.min(width, height) * (intensity / 100) * 0.25)); const numBlocks = Math.round(5 + 100 * (intensity / 100)); for (let i = 0; i < numBlocks; i++) { const blockSize = Math.floor(Math.random() * (maxBlockSize - 3)) + 3; const x1 = Math.floor(Math.random() * (width - blockSize)); const y1 = Math.floor(Math.random() * (height - blockSize)); const shape = Math.random() < 0.5 ? 'square' : 'circle'; if (shape === 'square') { for (let by = 0; by < blockSize; by++) { for (let bx = 0; bx < blockSize; bx++) { const index = ((y1 + by) * width + (x1 + bx)) * 4; data[index]=255-data[index]; data[index+1]=255-data[index+1]; data[index+2]=255-data[index+2]; } } } else { const cx = x1 + blockSize / 2; const cy = y1 + blockSize / 2; const radiusSq = (blockSize / 2) * (blockSize / 2); for (let by = 0; by < blockSize; by++) { for (let bx = 0; bx < blockSize; bx++) { const px = x1 + bx; const py = y1 + by; const distSq = (px + 0.5 - cx)**2 + (py + 0.5 - cy)**2; if (distSq < radiusSq) { const index = (py * width + px) * 4; data[index]=255-data[index]; data[index+1]=255-data[index+1]; data[index+2]=255-data[index+2]; } } } } } }
        // Effect 8: Recursive Draw
        function applyRecursiveDraw(ctx, baseImage, intensity) { const canvas = ctx.canvas; const width = canvas.width; const height = canvas.height; const maxDepth = Math.max(1, Math.min(5, Math.round(intensity / 20))); const scaleFactor = 0.45; if (lastAppliedImageData) { ctx.putImageData(lastAppliedImageData, 0, 0); } else if (originalImageData) { ctx.putImageData(originalImageData, 0, 0); } else { console.error("No image data to draw recursively."); return; } function drawLevel(currentDepth, targetX, targetY, targetW, targetH) { if (currentDepth <= 0 || targetW < 2 || targetH < 2) return; const nextW = targetW * scaleFactor; const nextH = targetH * scaleFactor; const positions = [ { dx: targetX, dy: targetY }, { dx: targetX + targetW - nextW, dy: targetY }, { dx: targetX, dy: targetY + targetH - nextH }, { dx: targetX + targetW - nextW, dy: targetY + targetH - nextH } ]; for (const pos of positions) { ctx.drawImage(baseImage, 0, 0, baseImage.width, baseImage.height, pos.dx, pos.dy, nextW, nextH); drawLevel(currentDepth - 1, pos.dx, pos.dy, nextW, nextH); } } drawLevel(maxDepth, 0, 0, width, height); }
        // Effect 9: Sierpinski Carpet (UPDATED with mirror)
        function applySierpinski(ctx, intensity) {
            const canvas = ctx.canvas; const width = canvas.width; const height = canvas.height;
            const maxDepth = Math.max(1, Math.min(6, Math.round(intensity / 16)));
            if (lastAppliedImageData) { ctx.putImageData(lastAppliedImageData, 0, 0); }
            else if (originalImageData) { ctx.putImageData(originalImageData, 0, 0); }
            else { console.error("No image data for Sierpinski effect."); return; }

            function drawCarpet(level, x, y, w, h) {
                if (level <= 0 || w < 1 || h < 1) return;
                const subW = w / 3;
                const subH = h / 3;
                const centerX = x + subW;
                const centerY = y + subH;

                // Draw mirrored center block instead of clearing
                ctx.save();
                ctx.translate(centerX + subW, centerY + subH); // Move origin to bottom-right corner of center square
                ctx.scale(-1, -1); // Flip horizontally and vertically
                // Draw the *canvas itself* (current state) from the center source region,
                // flipped into the destination region (which is the same center square)
                ctx.drawImage(canvas,
                              centerX, centerY, subW, subH, // Source rect (center square)
                              0, 0, subW, subH);           // Destination rect (relative to new flipped origin)
                ctx.restore();

                // Recurse for the 8 surrounding rectangles
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        if (row === 1 && col === 1) continue; // Skip center
                        drawCarpet(level - 1, x + col * subW, y + row * subH, subW, subH);
                    }
                }
            }
            drawCarpet(maxDepth, 0, 0, width, height);
        }
        // Effect 10: Fractal Tree (UPDATED)
        function applyFractalTree(ctx, depth, angleVariation, lengthFactor, lineWidth) {
             const canvas = ctx.canvas; const width = canvas.width; const height = canvas.height;
             if (lastAppliedImageData) { ctx.putImageData(lastAppliedImageData, 0, 0); }
             else if (originalImageData) { ctx.putImageData(originalImageData, 0, 0); }
             else { console.error("No image data for Fractal Tree effect."); return; }
             ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
             ctx.lineWidth = Math.max(0.1, lineWidth); // Use parameter, ensure minimum width
             ctx.lineCap = 'round';
             function drawBranch(x1, y1, angle, length, currentDepth) {
                 if (currentDepth <= 0 || length < 1) return;
                 const x2 = x1 + Math.cos(angle) * length;
                 const y2 = y1 + Math.sin(angle) * length;
                 ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                 const nextLength = length * lengthFactor; // Use parameter
                 const angle1 = angle - (Math.random() * angleVariation); // Use parameter
                 const angle2 = angle + (Math.random() * angleVariation); // Use parameter
                 drawBranch(x2, y2, angle1, nextLength, currentDepth - 1);
                 drawBranch(x2, y2, angle2, nextLength, currentDepth - 1);
             }
             const startX = width / 2; const startY = height;
             const initialLength = height / 4.5; const initialAngle = -Math.PI / 2;
             drawBranch(startX, startY, initialAngle, initialLength, depth); // Use parameter
        }
        // Effect 11: Recursive Shapes (Added back)
        function applyRecursiveShapes(ctx, intensity) {
            const canvas = ctx.canvas; const width = canvas.width; const height = canvas.height;
            const maxDepth = Math.max(2, Math.min(7, Math.round(intensity / 15) + 1));
            const baseLineWidth = 3;
            const lineWidth = Math.max(0.5, baseLineWidth * (1 - (intensity / 150)));
            if (lastAppliedImageData) { ctx.putImageData(lastAppliedImageData, 0, 0); }
            else if (originalImageData) { ctx.putImageData(originalImageData, 0, 0); }
            else { console.error("No image data for Recursive Shapes effect."); return; }
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.lineWidth = lineWidth;
            function drawShapesRecursive(level, x, y, w, h) {
                if (level <= 0 || w < 5 || h < 5) return;
                const subW = w / 3; const subH = h / 3;
                const centerX = x + w / 2; const centerY = y + h / 2;
                ctx.beginPath();
                if (Math.random() < 0.5) { ctx.rect(x + subW, y + subH, subW, subH); }
                else { ctx.arc(centerX, centerY, Math.min(subW, subH) / 2, 0, Math.PI * 2); }
                ctx.stroke();
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        if (row === 1 && col === 1) continue;
                        drawShapesRecursive(level - 1, x + col * subW, y + row * subH, subW, subH);
                    }
                }
            }
            drawShapesRecursive(maxDepth, 0, 0, width, height);
        }


        // --- Initial Setup ---
        updateVisibleControls(); // Set initial visibility of sliders

    </script>

</body>
</html>
```

I've added the "Recursive Shapes" option back to the dropdown and re-inserted the `applyRecursiveShapes` function and its corresponding `case` in `applyEffectLogic`. It should now be available aga